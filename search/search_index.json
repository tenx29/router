{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"About Router","text":"<p>Router is an open-source object-oriented framework for cross-server messaging on Roblox. Above all, Router is designed to be simple and easy to use, abstracting away the complexities of cross-server messaging. Router uses a custom Cross-Server Routing Protocol to communicate between servers.</p> <p>The Router library is written using strict type checking, making it integrate seamlessly with Roblox Studio's built-in code editor. Router is also designed to be used with Rojo and Wally, making it easy to integrate into your existing projects.</p> <p>Info</p> <p>Basic understanding of Luau is assumed.</p>"},{"location":"api-reference/csrpmessage/","title":"CsrpMessage","text":"<p>A CsrpMessage object represents a message that uses the CSRP specification.</p>"},{"location":"api-reference/csrpmessage/#constructors","title":"Constructors","text":""},{"location":"api-reference/csrpmessage/#csrpmessage-new","title":"CsrpMessage new","text":"<pre><code>CsrpMessage.new = function(sender: string?, recipients: {string} | string?, interactionId: string, fragment: number?, fragmentCount: number?, options: {[string]: any} | string?, body: string?): CsrpMessage\n</code></pre> <p>Returns a <code>CsrpMessage</code>. Throws an error if an argument is invalid.</p> <p>Arguments:</p> <ol> <li><code>string?</code> <code>sender</code> - The message sender's JobId.</li> <li><code>{string}</code> or <code>string?</code> <code>recipients</code> - The message recipients' JobIds.</li> <li><code>string</code> <code>interactionId</code> - The message interaction ID. Required for fragmented messages.</li> <li><code>number?</code> <code>fragment</code> - The message fragment number.</li> <li><code>number?</code> <code>fragmentCount</code> - The message fragment count. If nil, will be interpreted as 1.</li> <li><code>{[string]: any}</code> or <code>string?</code> <code>options</code> - The message options.</li> <li><code>string?</code> <code>body</code> - The message body.</li> </ol> <p>Note</p> <p>The first 6 arguments that form the message header must not contain semicolons (<code>;</code>). Additionally, the options argument must not contain equals signs (<code>=</code>) or commas (<code>,</code>). The message body can contain any characters.</p>"},{"location":"api-reference/csrpmessage/#csrpmessage-fromstring","title":"CsrpMessage fromString","text":"<pre><code>CsrpMessage.fromString = function(message: string): CsrpMessage\n</code></pre> <p>Parse a string into a <code>CsrpMessage</code>. Throws an error if the string is not a valid CSRP message.</p> <p>Arguments:</p> <ol> <li><code>string</code> <code>message</code> - The message string.</li> </ol>"},{"location":"api-reference/csrpmessage/#properties","title":"Properties","text":""},{"location":"api-reference/csrpmessage/#string-sender","title":"string? Sender","text":"<p>The message sender's JobId. Can be nil.</p>"},{"location":"api-reference/csrpmessage/#string-recipients","title":"string? Recipients","text":"<p>A comma-separated list of the message recipients' JobIds. Can be nil. An empty string indicates that the message is broadcasted to all servers. Prefixing a recipient with a <code>-</code> indicates that the recipient should not process the message.</p>"},{"location":"api-reference/csrpmessage/#string-interactionid","title":"string InteractionId","text":"<p>The message interaction ID. Used to identify fragments of the same message. Can also be used to identify request-response pairs.</p>"},{"location":"api-reference/csrpmessage/#number-fragment","title":"number? Fragment","text":"<p>The message fragment number. If nil, it will be interpreted as equal to FragmentCount if FragmentCount is not nil, otherwise 1.</p>"},{"location":"api-reference/csrpmessage/#number-fragmentcount","title":"number? FragmentCount","text":"<p>The total number of fragments in the message. If nil, it will be interpreted as 1.</p>"},{"location":"api-reference/csrpmessage/#string-options","title":"string? Options","text":"<p>A comma-separated list of the message options. Can be nil. Each option is in the format <code>key=value</code>. Not used by Router, but can be used by the user to store additional information about the message.</p>"},{"location":"api-reference/csrpmessage/#string-body","title":"string? Body","text":"<p>The message body. Can be nil and can contain any characters.</p>"},{"location":"api-reference/csrpmessage/#serialization","title":"Serialization","text":"<p>A CsrpMessage object can be serialized into a string using the built-in <code>tostring</code> function.</p> <pre><code>local message = CsrpMessage.new(\"sender\", \"recipient\", \"interactionId\", 1, 2, \"option1=value1,option2=value2\", \"body\")\nprint(tostring(message)) -- sender;recipient;interactionId;1;2;option1=value1,option2=value2;body\n</code></pre>"},{"location":"api-reference/csrpmessagebuilder/","title":"CsrpMessageBuilder","text":"<p>A utility class for creating valid CsrpMessage objects.</p>"},{"location":"api-reference/csrpmessagebuilder/#constructors","title":"Constructors","text":""},{"location":"api-reference/csrpmessagebuilder/#csrpmessagebuilder-new","title":"CsrpMessageBuilder new","text":"<pre><code>CsrpMessageBuilder.new = function()\n</code></pre> <p>Returns a new CsrpMessageBuilder object.</p>"},{"location":"api-reference/csrpmessagebuilder/#properties","title":"Properties","text":""},{"location":"api-reference/csrpmessagebuilder/#string-sender","title":"string Sender","text":"<p>The message sender's JobId. Defaults to the current server's JobId.</p>"},{"location":"api-reference/csrpmessagebuilder/#string-recipients","title":"{string} Recipients","text":"<p>A table of the message recipients' JobIds. Defaults to an empty table.</p>"},{"location":"api-reference/csrpmessagebuilder/#string-interactionid","title":"string InteractionId","text":"<p>The message interaction ID. A random GUID will be generated when calling the constructor.</p>"},{"location":"api-reference/csrpmessagebuilder/#string-any-options","title":"{[string]: any} Options","text":"<p>A table of additional message options. Defaults to an empty table.</p>"},{"location":"api-reference/csrpmessagebuilder/#string-body","title":"string? Body","text":"<p>The message body. Defaults to <code>nil</code>.</p>"},{"location":"api-reference/csrpmessagebuilder/#methods","title":"Methods","text":""},{"location":"api-reference/csrpmessagebuilder/#csrpmessagebuilder-setsender","title":"CsrpMessageBuilder SetSender","text":"<pre><code>CsrpMessageBuilder:SetSender(sender: string): CsrpMessageBuilder\n</code></pre> <p>Sets the message sender's JobId. Throws an error if the sender contains semicolons. Returns the CsrpMessageBuilder object for chaining.</p>"},{"location":"api-reference/csrpmessagebuilder/#csrpmessagebuilder-setrecipients","title":"CsrpMessageBuilder SetRecipients","text":"<pre><code>CsrpMessageBuilder:SetRecipients(recipients: {string}): CsrpMessageBuilder\n</code></pre> <p>Sets the message recipients' JobIds. Throws an error if any of the recipients contain semicolons. Returns the CsrpMessageBuilder object for chaining.</p>"},{"location":"api-reference/csrpmessagebuilder/#csrpmessagebuilder-addrecipient","title":"CsrpMessageBuilder AddRecipient","text":"<pre><code>CsrpMessageBuilder:AddRecipient(recipient: string, excludeCurrentForBroadcast: boolean?): CsrpMessageBuilder\n</code></pre> <p>Adds a recipient to the message. Throws an error if the recipient contains semicolons. Returns the CsrpMessageBuilder object for chaining.</p> <p>If <code>recipient</code> is an empty string, the message will be broadcast to all servers. If <code>excludeCurrentForBroadcast</code> is <code>true</code> (default), the current server's JobId will be excluded from the broadcast. Setting <code>excludeCurrentForBroadcast</code> to <code>false</code> will cause the message to be broadcast to all servers, including the current server.</p> <p>Warning</p> <p>If <code>excludeCurrentForBroadcast</code> is set to <code>false</code> when broadcasting to all servers, the sender will also receive the message. Keep this in mind in order to avoid infinite loops.</p>"},{"location":"api-reference/csrpmessagebuilder/#csrpmessagebuilder-excluderecipient","title":"CsrpMessageBuilder ExcludeRecipient","text":"<pre><code>CsrpMessageBuilder:ExcludeRecipient(recipient: string): CsrpMessageBuilder\n</code></pre> <p>Excludes a recipient from the message by adding it to the Recipients list and prefixing the recipient with <code>-</code>. Throws an error if the recipient contains semicolons. Returns the CsrpMessageBuilder object for chaining.</p>"},{"location":"api-reference/csrpmessagebuilder/#csrpmessagebuilder-setinteractionid","title":"CsrpMessageBuilder SetInteractionId","text":"<pre><code>CsrpMessageBuilder:SetInteractionId(interactionId: string): CsrpMessageBuilder\n</code></pre> <p>Sets the message interaction ID. Throws an error if the interaction ID contains semicolons. Returns the CsrpMessageBuilder object for chaining.</p>"},{"location":"api-reference/csrpmessagebuilder/#csrpmessagebuilder-setoption","title":"CsrpMessageBuilder SetOption","text":"<pre><code>CsrpMessageBuilder:SetOption(option: string, value: any): CsrpMessageBuilder\n</code></pre> <p>Sets an option on the message. Throws an error if the key or value contain semicolons, commas or equals signs. Returns the CsrpMessageBuilder object for chaining.</p>"},{"location":"api-reference/csrpmessagebuilder/#csrpmessagebuilder-setbody","title":"CsrpMessageBuilder SetBody","text":"<pre><code>CsrpMessageBuilder:SetBody(body: string): CsrpMessageBuilder\n</code></pre> <p>Sets the message body. Returns the CsrpMessageBuilder object for chaining.</p> <p>Note</p> <p>The message body can contain any characters, including semicolons, commas and equals signs.</p>"},{"location":"api-reference/csrpmessagebuilder/#csrpmessage-build","title":"CsrpMessage Build","text":"<pre><code>CsrpMessageBuilder:Build(): CsrpMessage\n</code></pre> <p>Builds the message. Returns the CsrpMessage object.</p>"},{"location":"api-reference/fragmentbuffer/","title":"FragmentBuffer","text":"<p>The <code>FragmentBuffer</code> class stores the fragments of a message for reassembly. It is used by the StreamConnection class.</p>"},{"location":"api-reference/fragmentbuffer/#constructors","title":"Constructors","text":""},{"location":"api-reference/fragmentbuffer/#fragmentbuffer-new","title":"FragmentBuffer new","text":"<pre><code>FragmentBuffer.new = function(timeout: number?): FragmentBuffer\n</code></pre> <p>Returns a new FragmentBuffer object with the given timeout. If <code>timeout</code> is not provided, 10 seconds will be used.</p> <p>Arguments:</p> <ol> <li><code>number?</code> <code>timeout</code> - The timeout in seconds.</li> </ol>"},{"location":"api-reference/fragmentbuffer/#properties","title":"Properties","text":""},{"location":"api-reference/fragmentbuffer/#number-timeout","title":"number Timeout","text":"<p>The buffer timeout in seconds. If a new fragment is not received within this time, the buffer will be cleared to prevent memory leaks.</p>"},{"location":"api-reference/fragmentbuffer/#number-cutofftime","title":"number CutOffTime","text":"<p>The time at which the buffer will be cleared if no new fragments are received.</p>"},{"location":"api-reference/fragmentbuffer/#number-totalfragments","title":"number TotalFragments","text":"<p>The number of fragments the full message is expected to have.</p>"},{"location":"api-reference/fragmentbuffer/#csrpmessage-fragments","title":"{CsrpMessage} Fragments","text":"<p>The received fragments of the message. The key is the fragment index and the value is the message fragment object.</p>"},{"location":"api-reference/fragmentbuffer/#events","title":"Events","text":""},{"location":"api-reference/fragmentbuffer/#rbxscriptsignal-timedout","title":"RBXScriptSignal TimedOut","text":"<p>Fired when the buffer times out.</p>"},{"location":"api-reference/fragmentbuffer/#methods","title":"Methods","text":""},{"location":"api-reference/fragmentbuffer/#void-add","title":"void Add","text":"<pre><code>FragmentBuffer:Add = function(fragment: CsrpMessage)\n</code></pre> <p>Adds a fragment to the buffer and resets the timeout timer.</p> <p>Arguments:</p> <ol> <li><code>CsrpMessage</code> <code>fragment</code> - The fragment to add.</li> </ol>"},{"location":"api-reference/fragmentbuffer/#boolean-iscomplete","title":"boolean IsComplete","text":"<pre><code>FragmentBuffer:IsComplete = function(): boolean\n</code></pre> <p>Returns whether the buffer contains all of the fragments of the message.</p>"},{"location":"api-reference/fragmentbuffer/#void-disable","title":"void Disable","text":"<pre><code>FragmentBuffer:Disable = function()\n</code></pre> <p>Disables the buffer. This will prevent additional fragments from being added to the buffer and will stop the timeout timer.</p>"},{"location":"api-reference/fragmentbuffer/#void-dispose","title":"void Dispose","text":"<pre><code>FragmentBuffer:Dispose = function()\n</code></pre> <p>Disables and clears the buffer.</p>"},{"location":"api-reference/fragmenter/","title":"Fragmenter","text":"<p>Utility module for splitting messages into smaller chunks and reassembling fragmented messages. Splits messages into chunks no larger than 1000 characters.</p>"},{"location":"api-reference/fragmenter/#functions","title":"Functions","text":""},{"location":"api-reference/fragmenter/#csrpmessage-fragmentmessage","title":"{CsrpMessage} FragmentMessage","text":"<pre><code>Fragmenter.FragmentMessage = function(message: CsrpMessage): {CsrpMessage}\n</code></pre> <p>Splits a message into smaller chunks. Returns a table of messages with a length no greater than 1000 characters. Automatically sets the fragment headers on the messages.</p> <p>Arguments:</p> <ol> <li><code>CsrpMessage</code> <code>message</code> - The message to fragment.</li> </ol>"},{"location":"api-reference/fragmenter/#csrpmessage-defragmentmessages","title":"[CsrpMessage] DefragmentMessages","text":"<pre><code>Fragmenter.DefragmentMessages = function(messages: {CsrpMessage}): CsrpMessage\n</code></pre> <p>Reassembles a table of fragmented messages into a single message. Automatically removes the fragment headers from the messages and sorts the fragments by their index.</p>"},{"location":"api-reference/messagestream/","title":"MessageStream","text":"<p>The <code>MessageStream</code> class is a wrapper for MessagingService that handles routing and fragmentation according to the CSRP specification. A MessageStream object represents a single MessagingService topic.</p>"},{"location":"api-reference/messagestream/#constructors","title":"Constructors","text":""},{"location":"api-reference/messagestream/#messagestream-new","title":"MessageStream new","text":"<pre><code>MessageStream.new = function(topic: string?, bufferTimeout: number?): MessageStream\n</code></pre> <p>Returns a new MessageStream object. If <code>topic</code> is not provided, <code>\"CSRP_GLOBAL\"</code> will be used. If <code>bufferTimeout</code> is not provided, 10 seconds will be used.</p> <p>Arguments:</p> <ol> <li><code>string?</code> <code>topic</code> - The MessagingService topic to use.</li> <li><code>number?</code> <code>bufferTimeout</code> - Timeout in seconds for fragment buffers.</li> </ol> <p>Danger</p> <p>Do not use a MessageStream or a MessagingService topic used by a MessageStream for sending or receiving messages that don't conform to the CSRP specification.</p>"},{"location":"api-reference/messagestream/#properties","title":"Properties","text":""},{"location":"api-reference/messagestream/#string-topic","title":"string Topic","text":"<p>The MessagingService topic used by the MessageStream.</p>"},{"location":"api-reference/messagestream/#methods","title":"Methods","text":""},{"location":"api-reference/messagestream/#messagestream-send","title":"MessageStream Send","text":"<pre><code>MessageStream:Send = function(message: CsrpMessage)\n</code></pre> <p>Send a CsrpMessage to the MessageStream's topic. Automatically fragments the message if it exceeds the maximum message size. Retries sending the message if it fails up to 10 times with a 1 second delay between each attempt.</p> <p>Arguments:</p> <ol> <li><code>CsrpMessage</code> <code>message</code> - The message to send.</li> </ol>"},{"location":"api-reference/messagestream/#streamconnection-subscribe","title":"StreamConnection Subscribe","text":"<pre><code>MessageStream:Subscribe = function(callback: (CsrpMessage, number) -&gt; ()): StreamConnection\n</code></pre> <p>Subscribe to the MessageStream. The callback will be invoked with the full message when all fragments of a message have been received. The callback will be invoked with two arguments: the CsrpMessage object and the time at which the last fragment of the message was received. The callback will only be invoked for messages that are intended for the current server.</p> <p>Arguments:</p> <ol> <li><code>(CsrpMessage, number) -&gt; ()</code> <code>callback</code> - The callback to invoke when a message is received.</li> </ol>"},{"location":"api-reference/routingutil/","title":"RoutingUtil","text":"<p>Utility module for checking if a message is intended for the current server.</p>"},{"location":"api-reference/routingutil/#functions","title":"Functions","text":""},{"location":"api-reference/routingutil/#boolean-iscurrentserversender","title":"boolean IsCurrentServerSender","text":"<pre><code>RoutingUtil.IsCurrentServerSender = function(message: CsrpMessage | string): boolean\n</code></pre> <p>Returns whether the message sender is the current server. If the message is a string, it will be parsed as a CsrpMessage.</p> <p>Arguments:</p> <ol> <li><code>CsrpMessage</code> or <code>string</code> <code>message</code> - The message to check.</li> </ol>"},{"location":"api-reference/routingutil/#boolean-iscurrentserverrecipient","title":"boolean IsCurrentServerRecipient","text":"<pre><code>RoutingUtil.IsCurrentServerRecipient = function(message: CsrpMessage | string): boolean\n</code></pre> <p>Returns whether the message is intended for the current server. If the message is a string, it will be parsed as a CsrpMessage.</p> <p>Arguments:</p> <ol> <li><code>CsrpMessage</code> or <code>string</code> <code>message</code> - The message to check.</li> </ol>"},{"location":"api-reference/streamconnection/","title":"StreamConnection","text":"<p>The <code>StreamConnection</code> class stores a single connection to a MessageStream along with the buffers used to store the fragments of a message. It is returned by the MessageStream:Subscribe method.</p>"},{"location":"api-reference/streamconnection/#constructors","title":"Constructors","text":""},{"location":"api-reference/streamconnection/#streamconnection-new","title":"StreamConnection new","text":"<pre><code>StreamConnection.new = function(connection: RBXScriptConnection, buffers: {[string]: FragmentBuffer}): StreamConnection\n</code></pre> <p>Returns a new StreamConnection object with the given connection and buffers.</p> <p>Arguments:</p> <ol> <li><code>RBXScriptConnection</code> <code>connection</code> - The connection to the MessageStream.</li> <li><code>{[string]: FragmentBuffer}</code> <code>buffers</code> - The buffers used to store the fragments of a message.</li> </ol>"},{"location":"api-reference/streamconnection/#properties","title":"Properties","text":""},{"location":"api-reference/streamconnection/#rbxscriptconnection-connection","title":"RBXScriptConnection Connection","text":"<p>The connection to the MessagingService topic.</p>"},{"location":"api-reference/streamconnection/#boolean-connected","title":"boolean Connected","text":"<p>Whether the connection is still active.</p>"},{"location":"api-reference/streamconnection/#string-fragmentbuffer-buffers","title":"{[string]: FragmentBuffer} Buffers","text":"<p>The buffers used to store the fragments of a message. A message with a given interaction ID will be stored in the buffer with the same key. A buffer is cleared when the last fragment of a message is received.</p>"},{"location":"api-reference/streamconnection/#methods","title":"Methods","text":""},{"location":"api-reference/streamconnection/#void-disconnect","title":"void Disconnect","text":"<pre><code>StreamConnection:Disconnect = function()\n</code></pre> <p>Disconnects the connection to the MessagingService topic and disposes of the buffers.</p>"},{"location":"getting-started/creating-messages/","title":"Creating Messages","text":"<p>In Router, messaging happens using CsrpMessage objects. The library also provides a CsrpMessageBuilder class to help with creating messages. A CsrpMessage can be created as follows:</p> <pre><code>-- We'll assume that Router is already defined here and in future snippets\nlocal CsrpMessageBuilder = require(Router.CsrpMessageBuilder)\nlocal message = CsrpMessageBuilder.new()\n    :AddRecipient(\"ae63c7e0-1b1e-4b1e-9c1e-1b1e4b1e9c1e\")\n    :setBody(\"Hello, world!\")\n    :Build()\n</code></pre> <p>The above snippet creates a message with a single recipient and a body of \"Hello, world!\". The CsrpMessage object is then stored in the <code>message</code> variable. Once sent, the message will be received by the server with the JobId <code>ae63c7e0-1b1e-4b1e-9c1e-1b1e4b1e9c1e</code>.</p> <p>Note</p> <p>Using the CsrpMessageBuilder class is recommended as it validates message headers as they are added. However, it is possible to create a CsrpMessage object directly by using the CsrpMessage constructor.</p>"},{"location":"getting-started/installation/","title":"Installation","text":""},{"location":"getting-started/installation/#studio","title":"Studio","text":"<ol> <li>Download the latest version of Router from the releases page.</li> <li>Insert the downloaded model into <code>ServerScriptService</code>.</li> <li>Router is now ready to use!</li> </ol>"},{"location":"getting-started/installation/#rojo-wally-recommended","title":"Rojo &amp; Wally (Recommended)","text":"<ol> <li>Make sure both Rojo and Wally are installed.</li> <li> <p>Add Router to the <code>wally.toml</code> file in your project's root directory:</p> <pre><code>[dependencies]\nname = \"tenx29/router@^0.1.0\"\n</code></pre> </li> <li> <p>Run <code>wally install</code>.</p> </li> <li>Router is now ready to use!</li> </ol>"},{"location":"getting-started/messaging/","title":"Sending &amp; Receiving Messages","text":"<p>Router provides a MessageStream class for sending and receiving messages. The MessageStream class automatically handles fragmentation and reassembly of messages as well as message routing. The MessageStream class is used to send and receive messages on a specific MessagingService topic.</p> <p>Danger</p> <p>Do not use a MessageStream or a MessagingService topic used by a MessageStream for sending or receiving messages that don't conform to the CSRP specification.</p>"},{"location":"getting-started/messaging/#sending-messages","title":"Sending Messages","text":"<p>Once a message is created, it must be sent to the other servers. There are two ways to send messages: using the Router library (recommended) and using the MessagingService directly.</p> <p>Note</p> <p>In these examples, we'll assume a variable named <code>message</code> has been created and contains a CsrpMessage object.</p>"},{"location":"getting-started/messaging/#using-router","title":"Using Router","text":"<p>To send a message using Router, you must first create a MessageStream object. A MessageStream object is used to send and receive messages on a specific MessagingService topic. The constructor takes a MessagingService topic as its only argument. The following snippet creates a MessageStream object using the default topic:</p> <pre><code>local MessageStream = require(Router.MessageStream)\nlocal stream = MessageStream.new()\n</code></pre> <p>This will create a new MessageStream object that uses the default <code>CSRP_GLOBAL</code> topic. Once a MessageStream object is created, it can be used to send messages:</p> <pre><code>stream:Send(message)\n</code></pre>"},{"location":"getting-started/messaging/#using-messagingservice","title":"Using MessagingService","text":"<p>Warning</p> <p>Using the MessagingService directly is not recommended as it can't fragment messages if they are too large.</p> <p>Sending messages using the MessagingService is very similar to sending messages using Router. The following snippet sends a CSRP message:</p> <pre><code>local MessagingService = game:GetService(\"MessagingService\")\nMessagingService:PublishAsync(\"CSRP_GLOBAL\", message)\n</code></pre>"},{"location":"getting-started/messaging/#receiving-messages","title":"Receiving Messages","text":"<p>To receive messages, you must first create a MessageStream object. A MessageStream object is used to send and receive messages on a specific MessagingService topic. The MessageStream automatically handles reassembly of fragmented messages as well as message routing. When subscribing to a MessageStream, you must provide a callback function that will be called when a message is received. The callback function can take up to two arguments: the CsrpMessage object and the time at which the last fragment of the message was received. The following snippet creates a MessageStream object and subscribes to it:</p> <pre><code>local MessageStream = require(Router.MessageStream)\nlocal stream = MessageStream.new()\nlocal connection = stream:Subscribe(function(message, lastFragmentTime)\n    -- Handle message\nend)\n</code></pre> <p>The connection will only be invoked for messages that are intended for the current server.</p>"},{"location":"getting-started/protocol/","title":"Cross-Server Routing Protocol","text":"<p>The Router library uses a custom Cross-Server Routing Protocol (CSRP) to communicate between servers. The full CSRP specification can be found at tenx29/roblox-csrp.</p> <p>The CSRP is designed to be a simple and easy to implement protocol that can be used to communicate between servers using Roblox's built-in MessagingService. Understanding the protocol is not required to use Router as the protocol-specific aspects are abstracted away by the library. However, the CSRP places some restrictions on message headers that may be useful to know about.</p>"},{"location":"getting-started/protocol/#routing","title":"Routing","text":"<p>While Roblox's MessagingService does not allow sending messages to a specific server, Router implements a system that ignores messages that are not intended for the current server.</p>"},{"location":"getting-started/protocol/#routing-examples","title":"Routing Examples","text":"<p>Below is a table containing some examples of how the CSRP routes messages between servers.</p> Recipient string Description <code>\"\"</code> The message is intended for all servers, including the current server. <code>\"-\"</code> The message isn't intended for any servers. <code>\"aaa111\"</code> The message is intended for the server with the job ID <code>aaa111</code>. <code>\"aaa111,bbb222\"</code> The message is intended for the servers with the job IDs <code>aaa111</code> and <code>bbb222</code>. <code>\",-bbb222\"</code> The message is intended for all servers except the server with the job ID <code>bbb222</code>. <code>\",-bbb222,-ccc333\"</code> The message is intended for all servers except the servers with the job IDs <code>bbb222</code> and <code>ccc333</code>. <code>aaa111,-aaa111\"</code> The message is intended for <code>aaa111</code>, but not <code>aaa111</code> (i.e. no servers)."}]}